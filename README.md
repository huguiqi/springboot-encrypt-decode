# springboot-encrypt-decode

> 关于对称加密，非对称加密，加密算法的学习


# 加密解密相关知识扫盲



## 1. 加密概念

密码学是研究编制密码和破译密码的技术科学。以数学为基础，在加密和解密、攻击和防守、矛和盾的对抗过程中交替发展起来。从数学算法的角度看，它包含对称密码算法、非对称密码算法和杂凑算法。

我们先来看下加密中经常提到的一些概念吧！

- **明文**：明文指的是未被加密过的原始数据。
- **密文**：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。
- **密钥**：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。



## 2. 对称加密

对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密。

> **加密过程如下**：明文 + 加密算法 + 私钥 => 密文
> **解密过程如下**：密文 + 解密算法 + 私钥 => 明文





![image-20230327185717948](/images/image-20230327185717948.png)



对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。 其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。

**如果你不是很理解，就看这个通俗易懂的例子**：

> 甲对乙说，我这有一把锁，以后我们互相传消息，就把消息放盒子里，然后用这个锁锁上再传，这个锁有两把一模一样的钥匙，咱俩一人一把，说完甲把钥匙递给了乙。

## 3. 非对称加密

非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。

> **被公钥加密过的密文只能被私钥解密，过程如下**：
> 明文 + 加密算法 + 公钥 => 密文， 密文 + 解密算法 + 私钥 => 明文





![image-20230327185908815](/images/image-20230327185908815.png)



由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

**如果你不是很理解，就看这个通俗易懂的例子**：

> 甲对乙说，我这里有A型号锁，对应钥匙A，我给你一大箱子A锁，但是钥匙A不给你，以后你给我发消息就用A锁锁在盒子里给我，然后我自己用钥匙A就能打开看。
> 乙对甲说，我这里有B型号锁，对应钥匙B，我给你一大箱子B锁，但是钥匙B不给你，以后你给我发消息就用B锁锁在盒子里给我，然后我自己用钥匙B就能打开看。

## 4. 常见加密算法比较

加密算法分 对称加密 和 非对称加密，其中对称加密算法的加密与解密 密钥相同，非对称加密算法的加密密钥与解密 密钥不同，此外，还有一类 **不需要密钥** 的 **散列算法**。

常见的 对称加密 算法主要有 **DES、3DES、AES** 等，常见的 非对称算法 主要有 **RSA、DSA** 等，散列算法 主要有 **SHA-1、MD5** 等。

### 4.1. 散列算法比较

| 名称  | 安全性 | 速度 |
| ----- | ------ | ---- |
| MD5   | 中     | 快   |
| SHA-1 | 高     | 慢   |

### 4.2. 对称加密算法比较

| 名称 | 密钥名称        | 运行速度 | 安全性 | 资源消耗 |
| ---- | --------------- | -------- | ------ | -------- |
| DES  | 56位            | 较快     | 低     | 中       |
| 3DES | 112位或168位    | 慢       | 中     | 高       |
| AES  | 128、192、256位 | 快       | 高     | 低       |

### 4.3. 非对称加密算法比较

| 名称 | 成熟度 | 运行速度 | 安全性 | 资源消耗 |
| ---- | ------ | -------- | ------ | -------- |
| RSA  | 高     | 中       | 高     | 中       |
| ECC  | 高     | 慢       | 高     | 高       |

对称加密 的 密钥管理比较难，不适合互联网，一般用于内部系统，安全性只能算中等，但加密速度快好 几个数量级 (软件加解密速度至少快 100 倍，每秒可以加解密数 M 比特 数据)，适合大数据量的加解密处理。非对称加密 的 密钥容易管理，安全性也较高，但是加密速度比较慢，适合 小数据量 加解密或数据签名。





## 5. 常见加密算法使用

### 5.1. MD5算法

> MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。
> 无论是多长的输入，MD5 都会输出长度为 128bits 的一个散列值串 (通常表示为32位的16进制数)。

Java使用案例：

```text
public static final byte[] computeMD5(byte[] content) {
    try {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        return md5.digest(content);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
}
```

参考测试代码


[MessageDigest是什么？](https://blog.csdn.net/qq_41918166/article/details/115552035)


### 5.2. SHA1算法

> SHA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。
> 对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要,表示为40位的十六进制数。
> 基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。

Java使用案例：

```text
public static byte[] computeSHA1(byte[] content) {
    try {
        MessageDigest sha1 = MessageDigest.getInstance("SHA1");
        return sha1.digest(content);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
}
```

### 5.3. HMAC算法

> MAC 是密钥相关的 哈希运算消息认证码（Hash-based Message Authentication Code）
> HMAC 运算利用 哈希算法 (MD5、SHA1 等)，以 一个密钥 和 一个消息 为输入，生成一个 消息摘要 作为 输出。
> HMAC 发送方 和 接收方 都有的 key 进行计算，而没有这把 key 的第三方，则是 无法计算 出正确的 散列值的，这样就可以 防止数据被篡改。

**MAC公式：MAC算法+密钥+要加密的信息=密文**

HMAC 是Keyed-Hashing for Message Authentication的缩写。
HMAC的MAC算法是hash算法，它可以是MD5, SHA-1或者 SHA-256，他们分别被称为HMAC-MD5，HMAC-SHA1， HMAC-SHA256。

HMAC用公式表示：

H(K XOR opad, H(K XOR ipad, text))

其中： 
> H：hash算法，比如（MD5，SHA-1，SHA-256） 
> B：块字节的长度，块是hash操作的基本单位。这里B=64。 
> L：hash算法计算出来的字节长度。(L=16 for MD5, L=20 for SHA-1)。 
> K：共享密钥，K的长度可以是任意的，但是为了安全考虑，还是推荐K的长度>B。当K长度大于B时候，会先在K上面执行hash算法，将得到的L长度结果作为新的共享密钥。 如果K的长度<B, 那么会在K后面填充0x00一直到等于长度B。 
> text： 要加密的内容 opad：外部填充常量，是 0x5C 重复B次。 
> ipad： 内部填充常量，是0x36 重复B次。 
> XOR： 异或运算。


**注意**：HMAC 算法实例在 多线程环境 下是 不安全的。但是需要在 多线程访问 时，进行同步的辅助类，使用 ThreadLocal 为 每个线程缓存 一个实例可以避免进行锁操作。

参考测试代码

### 5.4. AES算法

AES、DES、3DES 都是 对称 的 块加密算法，加解密 的过程是 可逆的。
常用的有 AES128、AES192、AES256 (默认安装的 JDK 尚不支持 AES256，需要安装对应的 jce 补丁进行升级 jce1.7，jce1.8)。

DES 加密算法是一种 分组密码，以 64 位为 分组对数据 加密，它的 密钥长度 是 56 位，加密解密 用 同一算法。DES 加密算法是对 密钥 进行保密，而 公开算法，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES加密算法加密的密文数据。
因此，破译 DES 加密算法实际上就是 搜索密钥的编码。 对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 2 ^ 56 次。3DES 是基于 DES 的 对称算法，对 一块数据 用 三个不同的密钥 进行 三次加密，强度更高。

> AES 加密算法是密码学中的 高级加密标准，该加密算法采用 对称分组密码体制，密钥长度的最少支持为 128 位、 192 位、256 位，分组长度 128 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 区块加密标准。AES 本身就是为了取代 DES 的，AES 具有更好的 安全性、效率 和 灵活性。
>

DES:分组块大小--64位
AES:分组块大小--128位

AES 加密算法采用分组密码体制，每个分组数据的长度为128位即16个字节，密钥长度可以是128位16个字节、192位或256位，一共有四种加密模式，我们通常采用需要初始向量 IV 的 CBC 模式，初始向量的长度也是128位16个字节。

AES 加密的五个关键词，分别是：分组密码体制、Padding、密钥、初始向量 IV 和四种加密模式。



#### 5.4.1 分组密码体制
所谓分组密码体制就是指将明文切成一段一段的来加密，然后再把一段一段的密文拼起来形成最终密文的加密方式。AES 采用分组密码体制，即 AES 加密会首先把明文切成一段一段的，而且每段数据的长度要求必须是128位16个字节，如果最后一段不够16个字节了，就需要用 Padding 来把这段数据填满16个字节，然后分别对每段数据进行加密，最后再把每段加密数据拼起来形成最终的密文。



#### 5.4.2 Padding
Padding 就是用来把不满16个字节的分组数据填满16个字节用的，它有三种模式 PKCS5、PKCS7 和NOPADDING。PKCS5 是指分组数据缺少几个字节，就在数据的末尾填充几个字节的几，比如缺少5个字节，就在末尾填充5个字节的5。PKCS7 是指分组数据缺少几个字节，就在数据的末尾填充几个字节的0，比如缺少7个字节，就在末尾填充7个字节的0。NoPadding 是指不需要填充，也就是说数据的发送方肯定会保证最后一段数据也正好是16个字节。那如果在PKCS5 模式下，最后一段数据的内容刚好就是16个16怎么办？那解密端就不知道这一段数据到底是有效数据还是填充数据了，因此对于这种情况，PKCS5 模式会自动帮我们在最后一段数据后再添加16个字节的数据，而且填充数据也是16个16，这样解密段就能知道谁是有效数据谁是填充数据了。PKCS7 最后一段数据的内容是16个0，也是同样的道理。解密端需要使用和加密端同样的 Padding 模式，才能准确的识别有效数据和填充数据。我们开发通常采用 PKCS7 Padding 模式。



#### 5.4.3 初始向量IV
初始向量 IV 的作用是使加密更加安全可靠，我们使用 AES 加密时需要主动提供初始向量，而且只需要提供一个初始向量就够了，后面每段数据的加密向量都是前面一段的密文。初始向量 IV 的长度规定为128位16个字节，初始向量的来源为随机生成。至于为什么初始向量能使加密更安全可靠，会在下面的加密模式中提到。



#### 5.4.4 密钥
AES 要求密钥的长度可以是128位16个字节、192位或者256位，位数越高，加密强度自然越大，但是加密的效率自然会低一些，因此要做好衡量。我们开发通常采用128位16个字节的密钥，我们使用 AES 加密时需要主动提供密钥，而且只需要提供一个密钥就够了，每段数据加密使用的都是这一个密钥，密钥来源为随机生成（我们开发时传入的那个为初始密钥，除了初始密钥以外，后面每一轮的密钥都是由上一轮的密钥扩展而来的，密钥扩展有四个步骤：排列、置换、与轮常量异或、生成下一轮密钥的其他列）。



5.5 四种加密模式
AES 一共有四种加密模式，分别是:
* ECB（电子密码本模式）
* CBC（密码分组链接模式）
* CFB
* OFB
* 我们一般使用的是 CBC 模式比较多

四种模式中除了 ECB 相对不安全之外，其它三种模式的区别并没有那么大

**ECB 模式是最基本的加密模式，即仅仅使用明文和密钥来加密数据，相同的明文块会被加密成相同的密文块，这样明文和密文的结构将是完全一样的，就会更容易被破解，
相对来说不是那么安全，因此很少使用，而 CBC 模式则比 ECB 模式多了一个初始向量 IV，加密的时候，第一个明文块会首先和初始向量 IV 做异或操作，然后再经过密钥加密，
然后第一个密文块又会作为第二个明文块的加密向量来异或，依次类推下去，这样相同的明文块加密出的密文块就是不同的， 明文的结构和密文的结构也将是不同的，因此更加安全，我们常用的就是 CBC 加密模式**


**区块结构：涉及区块链知识体系**


**AES加密解密见代码**


### 5.5. RSA算法

> RSA 加密算法是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够抵抗到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。

#### 5.5.1 算法原理

> RSA 加密算法本身基于一个简单的数论知识：给出两个素数，很容易将它们相乘，然而给出它们的乘积，想得到这两个素数就显得尤为困难。
> 如果能够解决大整数（比如几百位的整数）分解的快速方法，那么 RSA 算法将轻易被破解。

**公钥私钥生成数字原理:**

1）准备两个非常大的素数p和q（转换成二进制后1024个二进制位或者更多，位数越多越难破解）；
2）利用字符串模拟计算大素数p和q的乘积n=p*q；
3）同样方法计算`m=(p-1)*(q-1)` ，这里的m为n的欧拉函数；
4）找到一个数e(1 < e < m)，满足`gcd(m,e)=1`（即e和m互素）；
5）计算e在模m域上的逆元d（即满足ed mod m =1）；
6）至此，公钥和私钥生成完毕：`(n,e)`为公钥，`(n,d)` 为私钥；

**加密数学原理：**

> 对于明文 ，用公钥 `x` 对`(n,e)`加密的过程，就是将 `x` 转换成数字（字符串的话取其 ASCII码或者 unicode 值），
> 然后通过幂取模计算出 ，其中  就是密文；

$$ y= x^e \bmod n $$



[github支持的数学表达式写法参考](https://docs.github.com/cn/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions)
[编写数学表达式参考这里](https://en.wikibooks.org/wiki/LaTeX/Mathematics)



[算法参考文章](https://zhuanlan.zhihu.com/p/450180396)


#### 关于rsa加密需要分段且需要减去11个字节长度的问题

> RSA加解密中必须考虑到的密钥长度、明文长度和密文长度问题。明文长度需要小于密钥长度，
> 而密文长度则等于密钥长度。因此当加密内容长度大于密钥长度时，有效的RSA加解密就需要对内容进行分段。

这是因为，RSA算法本身要求加密内容也就是明文长度m必须0<m<密钥长度n。
如果小于这个长度就需要进行padding，因为如果没有padding，就无法确定解密后内容的真实长度，字符串之类的内容问题还不大，以0作为结束符，但对二进制数据就很难，因为不确定后面的0是内容还是内容结束符。而只要用到padding，那么就要占用实际的明文长度，于是实际明文长度需要减去padding字节长度。
我们一般使用的padding标准有NoPPadding、OAEPPadding、PKCS1Padding等，其中PKCS#1建议的padding就占用了11个字节。

**这样，对于1024长度的密钥。128字节（1024bits）-减去11字节正好是117字节，但对于RSA加密来讲，padding也是参与加密的，所以，依然按照1024bits去理解，但实际的明文只有117字节了。**

所以如果要对任意长度的数据进行加密，就需要将数据分段后进行逐一加密，并将结果进行拼接。同样，解码也需要分段解码，并将结果进行拼接。




**RSA加密解密例子见代码**


[RSA在线加解密](https://try8.cn/tool/cipher/rsa)

## 6. 数字签名

数字签名技术是基于非对称加密技术之上的，

数字签名特点:

  * 防篡改：数据不会被修改。
  * 防抵赖：消息签署者不能抵赖。
  * 防伪造：发送的消息不能够伪造。

**MAC算法有防篡改、防伪造的特点，但是不具有防抵赖特性。
因为MAC算法，它只能保证传递的消息是经过验证的，但不能对消息发送者的身份进行验证，
原因就在于消息发送方和接收方拥有同样的密钥，所以双方可以抵赖，否认消息是他发送的，因此在理解的时候一定要区分消息验证和身份验证。**




## 7. 加密解密相关知识脑图



![encrypt_decode](/images/encrypt_decode.png)



[参考文章](https://zhuanlan.zhihu.com/p/605549569)